// Generated by CoffeeScript 1.6.3
(function(exports) {
  var Array2d, MargolusNeighborehoodField, Rules, div, math_util, mod, module_rules;
  if (typeof require !== "undefined" && require !== null) {
    math_util = require("./math_util");
    module_rules = require("./rules");
  } else {
    math_util = this.math_util;
    module_rules = this.rules;
  }
  div = math_util.div, mod = math_util.mod;
  Rules = module_rules.Rules;
  /*
  A 2-dimensional array of bytes!, with row-first organization
  */

  exports.Array2d = Array2d = (function() {
    function Array2d(width, height) {
      var e;
      this.width = width;
      this.height = height;
      this.num_cells = this.width * this.height;
      this.data = (function() {
        try {
          return new Int8Array(this.num_cells);
        } catch (_error) {
          e = _error;
          return [];
        }
      }).call(this);
    }

    Array2d.prototype.fill = function(v) {
      return math_util.fill_array(this.data, this.num_cells, v);
    };

    Array2d.prototype.cell_index = function(x, y) {
      return y * this.width + x;
    };

    Array2d.prototype.set = function(x, y, v) {
      return this.data[this.cell_index(x, y)] = v;
    };

    Array2d.prototype.set_wrapped = function(x, y, v) {
      return this.data[this.cell_index(mod(x, this.width), mod(y, this.height))] = v;
    };

    Array2d.prototype.get = function(x, y) {
      return this.data[this.cell_index(x, y)];
    };

    Array2d.prototype.toggle = function(x, y) {
      return this.data[this.cell_index(x, y)] ^= 1;
    };

    Array2d.prototype.size = function() {
      return [this.width, this.height];
    };

    Array2d.prototype.get_wrapped = function(x, y) {
      return this.data[this.cell_index(mod(x, this.width), mod(y, this.height))];
    };

    /*
    #Random fill block with given percentage
    */


    Array2d.prototype.random_fill = function(x0, y0, x1, y1, percent) {
      var data, i, x, y, _i, _j;
      data = this.data;
      for (y = _i = y0; _i < y1; y = _i += 1) {
        i = this.cell_index(x0, y);
        for (x = _j = x0; _j < x1; x = _j += 1) {
          data[i] = (Math.random() <= percent ? 1 : 0);
          i++;
        }
      }
      return null;
    };

    Array2d.prototype.fill_box = function(x0, y0, x1, y1, value) {
      var data, i, x, y, _i, _j;
      data = this.data;
      for (y = _i = y0; _i < y1; y = _i += 1) {
        i = this.cell_index(x0, y);
        for (x = _j = x0; _j < x1; x = _j += 1) {
          data[i] = value;
          i++;
        }
      }
      return null;
    };

    Array2d.prototype.fill_outside_box = function(x0, y0, x1, y1, value) {
      var h, w;
      w = this.width;
      h = this.height;
      this.fill_box(0, 0, w, y0);
      this.fill_box(0, y0, x0, y1);
      this.fill_box(x1, y0, w, y1);
      return this.fill_box(0, y1, w, h);
    };

    /*
    Find minimal bounding box for the given block of the field
    */


    Array2d.prototype.bounding_box = function(x0, y0, x1, y1) {
      var x, xmax, xmin, y, ymax, ymin, _i, _j;
      xmin = x1 - 1;
      ymin = y1 - 1;
      xmax = x0;
      ymax = y0;
      for (y = _i = y0; _i < y1; y = _i += 1) {
        for (x = _j = x0; _j < x1; x = _j += 1) {
          if (this.get(x, y) !== 0) {
            xmin = Math.min(xmin, x);
            xmax = Math.max(xmax, x);
            ymin = Math.min(ymin, y);
            ymax = Math.max(ymax, y);
          }
        }
      }
      if (xmax < xmin || ymax < ymin) {
        return [x0, y0, x0, y0];
      } else {
        return [xmin, ymin, xmax + 1, ymax + 1];
      }
    };

    Array2d.prototype.is_nonempty = function(x0, y0, x1, y1) {
      var x, y, _i, _j;
      for (y = _i = y0; _i < y1; y = _i += 1) {
        for (x = _j = x0; _j < x1; x = _j += 1) {
          if (this.get(x, y) !== 0) {
            return true;
          }
        }
      }
      return false;
    };

    /*
    return list of coordinates of active cells. Coordinates are relativeto the origin of the box
    */


    Array2d.prototype.get_cells = function(x0, y0, x1, y1) {
      var rval, x, y, _i, _j;
      rval = [];
      for (y = _i = y0; _i < y1; y = _i += 1) {
        for (x = _j = x0; _j < x1; x = _j += 1) {
          if (this.get_wrapped(x, y) !== 0) {
            rval.push([x - x0, y - y0]);
          }
        }
      }
      return rval;
    };

    /*
    Put list of cells to the field
    */


    Array2d.prototype.put_cells = function(lst, x, y, value) {
      var h, w, xx, yy, _i, _len, _ref;
      if (value == null) {
        value = 1;
      }
      w = this.width;
      h = this.height;
      for (_i = 0, _len = lst.length; _i < _len; _i++) {
        _ref = lst[_i], xx = _ref[0], yy = _ref[1];
        this.set(mod(x + xx, w), mod(y + yy, h), value);
      }
      return null;
    };

    Array2d.prototype.pick_pattern_at = function(x, y, x0, y0, erase, range) {
      var cells, do_pick_at, h, is_visited, key, self, visit, visited, w;
      if (erase == null) {
        erase = false;
      }
      if (range == null) {
        range = 4;
      }
      self = this;
      w = this.width;
      h = this.height;
      visited = {};
      cells = [];
      key = function(x, y) {
        return "" + x + "#" + y;
      };
      is_visited = function(x, y) {
        return visited.hasOwnProperty(key(x, y));
      };
      visit = function(x, y) {
        return visited[key(x, y)] = true;
      };
      do_pick_at = function(x, y) {
        var dx, dy, wx, wy, y1, _i, _j;
        wx = mod(x, w);
        wy = mod(y, h);
        if (is_visited(wx, wy) || self.get(wx, wy) === 0) {
          return;
        }
        visit(wx, wy);
        cells.push([x - x0, y - y0]);
        if (erase) {
          self.set(wx, wy, 0);
        }
        for (dy = _i = -range; _i <= range; dy = _i += 1) {
          y1 = y + dy;
          for (dx = _j = -range; _j <= range; dx = _j += 1) {
            if (dy === 0 && dx === 0) {
              continue;
            }
            do_pick_at(x + dx, y1);
          }
        }
        return cells;
      };
      return do_pick_at(x, y);
    };

    return Array2d;

  })();
  /*
  A field with Margolus neighborehood
  */

  return exports.MargolusNeighborehoodField = MargolusNeighborehoodField = (function() {
    function MargolusNeighborehoodField(field, rule) {
      this.field = field;
      if (field.width % 2 !== 0 || field.height % 2 !== 0) {
        throw "Field size must be even, not " + field.width + "x" + field.height;
      }
      this.generation = 0;
      this.phase = 0;
      this.set_rule(rule);
    }

    MargolusNeighborehoodField.prototype.set_rule = function(rule) {
      this.rule = rule;
      return this.inverse_rule = null;
    };

    MargolusNeighborehoodField.prototype.transform_from = function(x0, y0, rule) {
      if (rule.call != null) {
        return this.transform_from_general(x0, y0, rule);
      } else {
        return this.transform_from_2state(x0, y0, rule);
      }
    };

    MargolusNeighborehoodField.prototype.transform_from_2state = function(x0, y0, rule) {
      var X, Y, a, b, c, d, data, dx, dy, field, h, w, x, y, _i, _j;
      field = this.field;
      data = field.data;
      w = field.width;
      h = field.height;
      a = 0;
      for (y = _i = y0; _i < h; y = _i += 2) {
        dy = (y + 1 < h ? w : w * (1 - h));
        a = y * w + x0;
        for (x = _j = x0; _j < w; x = _j += 2) {
          dx = (x + 1 < w ? 1 : 1 - w);
          b = a + dx;
          c = a + dy;
          d = b + dy;
          X = data[a] | (data[b] << 1) | (data[c] << 2) | (data[d] << 3);
          Y = rule[X];
          if (Y !== X) {
            data[a] = Y & 1;
            data[b] = (Y >> 1) & 1;
            data[c] = (Y >> 2) & 1;
            data[d] = (Y >> 3) & 1;
          }
          a += 2;
        }
      }
      return null;
    };

    MargolusNeighborehoodField.prototype.transform_from_general = function(x0, y0, general_rule) {
      var a, b, c, d, data, dx, dy, field, h, w, x, y, _i, _j;
      field = this.field;
      data = field.data;
      w = field.width;
      h = field.height;
      a = 0;
      for (y = _i = y0; _i < h; y = _i += 2) {
        dy = (y + 1 < h ? w : w * (1 - h));
        a = y * w + x0;
        for (x = _j = x0; _j < w; x = _j += 2) {
          dx = (x + 1 < w ? 1 : 1 - w);
          b = a + dx;
          c = a + dy;
          d = b + dy;
          general_rule(data, a, b, c, d);
          a += 2;
        }
      }
      return null;
    };

    MargolusNeighborehoodField.prototype.transform = function() {
      var xy0;
      xy0 = this.phase;
      this.transform_from(xy0, xy0, this.rule);
      this.phase = mod(this.phase + 1, 2);
      return this.generation++;
    };

    MargolusNeighborehoodField.prototype.untransform = function() {
      var xy0;
      xy0 = mod(this.phase - 1, 2);
      this.transform_from(xy0, xy0, this.get_inverse_rule());
      this.phase = mod(this.phase - 1, 2);
      return this.generation--;
    };

    /*
    Calculates reverse rule and returns it.
    Raises an exception, if rule is not reversible
    */


    MargolusNeighborehoodField.prototype.get_inverse_rule = function() {
      var ir;
      if ((ir = this.inverse_rule) != null) {
        return ir;
      } else {
        return this.inverse_rule = (function() {
          if (this.rule.call != null) {
            if (this.rule.inverse == null) {
              throw "Inverse rule not provided!";
            }
            return this.rule.inverse;
          } else {
            return Rules.reverse(this.rule);
          }
        }).call(this);
      }
    };

    MargolusNeighborehoodField.prototype.clear = function() {
      this.set_generation(0);
      return this.field.fill(0);
    };

    MargolusNeighborehoodField.prototype.set_generation = function(g) {
      this.phase = mod(g, 2);
      return this.generation = g;
    };

    MargolusNeighborehoodField.prototype.snap_below = function(x) {
      return x - mod(x + this.phase, 2);
    };

    MargolusNeighborehoodField.prototype.snap_upper = function(x) {
      return x + mod(x + this.phase, 2);
    };

    MargolusNeighborehoodField.prototype.snap_box = function(_arg) {
      var x0, x1, y0, y1;
      x0 = _arg[0], y0 = _arg[1], x1 = _arg[2], y1 = _arg[3];
      return [this.snap_below(x0), this.snap_below(y0), this.snap_upper(x1), this.snap_upper(y1)];
    };

    return MargolusNeighborehoodField;

  })();
})(typeof exports !== "undefined" && exports !== null ? exports : this["reversible_ca"] = {});

/*
//@ sourceMappingURL=reversible_ca.map
*/
