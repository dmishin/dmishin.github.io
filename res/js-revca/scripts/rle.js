// Generated by CoffeeScript 1.6.3
/*
Library for RLE ensocing and decoding, used by Life programs
*/

(function(exports) {
  /*
  Encoder, creating RLE string from cell data
  */

  var RLEEncoder, remove_whitespaces;
  RLEEncoder = (function() {
    function RLEEncoder() {
      this.stack = [];
      this.cur_item = null;
    }

    RLEEncoder.prototype.get_cur_char = function() {
      var ci;
      ci = this.cur_item;
      if (ci == null) {
        return null;
      } else {
        return ci[0];
      }
    };

    RLEEncoder.prototype.put_cell = function(value) {
      return this.put((value ? "o" : "b"));
    };

    RLEEncoder.prototype.newline = function() {
      return this.put("$");
    };

    RLEEncoder.prototype.put = function(c) {
      var cur_char;
      if (c !== "b" && c !== "o" && c !== "$") {
        throw "Character " + c + " is wrong";
      }
      cur_char = this.get_cur_char();
      if (c === cur_char) {
        return this.cur_item[1] += 1;
      } else {
        if (c === "$" && cur_char === "b") {
          this.pop();
          return this.put(c);
        } else {
          this.cur_item = [c, 1];
          return this.stack.push(this.cur_item);
        }
      }
    };

    RLEEncoder.prototype.pop = function() {
      var stk;
      stk = this.stack;
      stk.pop();
      if (stk.length === 0) {
        return this.cur_item = null;
      } else {
        return this.cur_item = stk[stk.length - 1];
      }
    };

    RLEEncoder.prototype.trim_zeros = function() {
      var c, len, stk, _results;
      stk = this.stack;
      _results = [];
      while (true) {
        len = stk.length;
        if (len > 0) {
          c = stk[len - 1][0];
          if (c === "$" || c === "b") {
            stk.pop();
            continue;
          }
        }
        break;
      }
      return _results;
    };

    RLEEncoder.prototype.get_rle = function() {
      var c, cnt, output, _i, _len, _ref, _ref1;
      this.trim_zeros();
      output = "";
      _ref = this.stack;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], c = _ref1[0], cnt = _ref1[1];
        if (cnt > 1) {
          output += cnt;
        }
        output += c;
      }
      return output;
    };

    return RLEEncoder;

  })();
  /*
  Parse Life RLE string, producing 2 arrays: Xs and Ys.
  */

  exports.parse_rle = function(rle_string, put_cell) {
    var c, count, curCount, i, j, x, y, _i, _j, _ref;
    x = 0;
    y = 0;
    curCount = 0;
    for (i = _i = 0, _ref = rle_string.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      c = rle_string.charAt(i);
      if (("0" <= c && c <= "9")) {
        curCount = curCount * 10 + parseInt(c, 10);
      } else {
        count = Math.max(curCount, 1);
        curCount = 0;
        switch (c) {
          case "b":
            x += count;
            break;
          case "$":
            y += count;
            x = 0;
            break;
          case "o":
            for (j = _j = 0; _j < count; j = _j += 1) {
              put_cell(x, y);
              x += 1;
            }
            break;
          default:
            throw new Error("Unexpected character '" + c + "' at position " + i);
        }
      }
    }
    return null;
  };
  return exports.remove_whitespaces = remove_whitespaces = function(s) {
    return s.replace(/\s+/g, "");
  };
})(typeof exports !== "undefined" && exports !== null ? exports : this["rle"] = {});

/*
//@ sourceMappingURL=rle.map
*/
