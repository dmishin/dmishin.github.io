// Generated by CoffeeScript 1.6.3
(function(exports) {
  var Array2d, Bits, Cells, MargolusNeighborehoodField, Maximizer, Point, Rules, div, evaluateCellList, evaluateLabelledCellList, extend_array, getDualTransform, mod, module_math_util, module_reversible_ca, module_rle, module_rules, parse_rle, transformMatrix2BitBlockMap;
  if (typeof require !== "undefined" && require !== null) {
    module_rle = require("./rle");
    module_rules = require("./rules");
    module_math_util = require("./math_util");
    module_reversible_ca = require("./reversible_ca");
  } else {
    module_rle = this.rle;
    module_rules = this.rules;
    module_math_util = this.math_util;
    module_reversible_ca = this.reversible_ca;
  }
  parse_rle = module_rle.parse_rle;
  Rules = module_rules.Rules, Bits = module_rules.Bits;
  Maximizer = module_math_util.Maximizer, mod = module_math_util.mod, div = module_math_util.div;
  MargolusNeighborehoodField = module_reversible_ca.MargolusNeighborehoodField, Array2d = module_reversible_ca.Array2d;
  exports.Cells = Cells = {
    areEqual: function(l1, l2) {
      var i, xy1, xy2, _i, _ref;
      if (l1.length !== l2.length) {
        return false;
      }
      for (i = _i = 0, _ref = l1.length; _i < _ref; i = _i += 1) {
        xy1 = l1[i];
        xy2 = l2[i];
        if (xy1[0] !== xy2[0] || xy1[1] !== xy2[1]) {
          return false;
        }
      }
      return true;
    },
    sortXY: function(lst) {
      return lst.sort(function(_arg, _arg1) {
        var x1, x2, y1, y2;
        x1 = _arg[0], y1 = _arg[1];
        x2 = _arg1[0], y2 = _arg1[1];
        return (y1 - y2) || (x1 - x2);
      });
    },
    bounds: function(lst) {
      var i, x, x0, x1, y, y0, y1, _i, _ref, _ref1, _ref2, _ref3;
      if (lst.length === 0) {
        return [0, 0, 0, 0];
      }
      _ref1 = (_ref = lst[0], x0 = _ref[0], y0 = _ref[1], _ref), x1 = _ref1[0], y1 = _ref1[1];
      for (i = _i = 1, _ref2 = lst.length; _i < _ref2; i = _i += 1) {
        _ref3 = lst[i], x = _ref3[0], y = _ref3[1];
        x0 = Math.min(x0, x);
        x1 = Math.max(x1, x);
        y0 = Math.min(y0, y);
        y1 = Math.max(y1, y);
      }
      return [x0, y0, x1, y1];
    },
    transform: function(lst, tfm, need_normalize) {
      var lst1, t00, t01, t10, t11, x, x1, y, y1;
      if (need_normalize == null) {
        need_normalize = true;
      }
      t00 = tfm[0], t01 = tfm[1], t10 = tfm[2], t11 = tfm[3];
      lst1 = (function() {
        var _i, _len, _ref, _results;
        _results = [];
        for (_i = 0, _len = lst.length; _i < _len; _i++) {
          _ref = lst[_i], x = _ref[0], y = _ref[1];
          x += 0.5;
          y += 0.5;
          x1 = (t00 * x + t01 * y - 0.5) | 0;
          y1 = (t10 * x + t11 * y - 0.5) | 0;
          _results.push([x1, y1]);
        }
        return _results;
      })();
      if (need_normalize) {
        return this.normalize(lst1);
      } else {
        return lst1;
      }
    },
    normalize: function(lst1) {
      return this.sortXY(this.normalizeXY(lst1));
    },
    normalizeXY: function(lst1) {
      var xmin, ymin, _ref;
      _ref = this.bounds(lst1), xmin = _ref[0], ymin = _ref[1];
      xmin -= mod(xmin, 2);
      ymin -= mod(ymin, 2);
      return this.offset(lst1, -xmin, -ymin);
    },
    togglePhase: function(cells) {
      var cells1, x, y;
      cells1 = (function() {
        var _i, _len, _ref, _results;
        _results = [];
        for (_i = 0, _len = cells.length; _i < _len; _i++) {
          _ref = cells[_i], x = _ref[0], y = _ref[1];
          _results.push([x + 1, y + 1]);
        }
        return _results;
      })();
      return Cells.normalizeXY(cells1);
    },
    offset: function(lst, dx, dy) {
      var xy, _i, _len;
      for (_i = 0, _len = lst.length; _i < _len; _i++) {
        xy = lst[_i];
        xy[0] += dx;
        xy[1] += dy;
      }
      return lst;
    },
    extent: function(lst) {
      var x1, y1, _, _ref;
      _ref = this.bounds(lst), _ = _ref[0], _ = _ref[1], x1 = _ref[2], y1 = _ref[3];
      return [x1, y1];
    },
    find: function(lst, _arg) {
      var i, x, xi, y, yi, _i, _len, _ref;
      x = _arg[0], y = _arg[1];
      for (i = _i = 0, _len = lst.length; _i < _len; i = ++_i) {
        _ref = lst[i], xi = _ref[0], yi = _ref[1];
        if (xi === x && yi === y) {
          return i;
        }
      }
      return null;
    },
    /*
    Convert list of alive cells to RLE. List of cells must be sorted by Y, then by X, and coordinates of origin must be at (0,0)
    */

    to_rle: function(cells) {
      var appendNumber, count, dx, dy, endWritingBlock, i, rle, x, xi, y, yi, _i, _len, _ref;
      rle = "";
      count = 0;
      appendNumber = function(n, c) {
        if (n > 1) {
          rle += n;
        }
        return rle += c;
      };
      endWritingBlock = function() {
        if (count > 0) {
          appendNumber(count, "o");
          return count = 0;
        }
      };
      x = -1;
      y = 0;
      for (i = _i = 0, _len = cells.length; _i < _len; i = ++_i) {
        _ref = cells[i], xi = _ref[0], yi = _ref[1];
        dy = yi - y;
        if (dy < 0) {
          throw new Error("Cell list are not sorted by Y");
        }
        if (dy > 0) {
          endWritingBlock();
          appendNumber(dy, "$");
          x = -1;
          y = yi;
        }
        dx = xi - x;
        if (dx <= 0) {
          throw new Error("Cell list is not sorted by X");
        }
        if (dx === 1) {
          count++;
        } else if (dx > 1) {
          endWritingBlock();
          appendNumber(dx - 1, "b");
          count = 1;
        }
        x = xi;
      }
      endWritingBlock();
      return rle;
    },
    /*
    Convert RLE-encoded configutaion back to cell list
    */

    from_rle: function(rle) {
      var cells;
      cells = [];
      parse_rle(rle, function(x, y) {
        return cells.push([x, y]);
      });
      return cells;
    },
    energy: function(lst) {
      var e, i, j, n, x1, x2, y1, y2, _i, _j, _len, _ref, _ref1, _ref2;
      n = lst.length;
      e = 0;
      for (i = _i = 0, _len = lst.length; _i < _len; i = ++_i) {
        _ref = lst[i], x1 = _ref[0], y1 = _ref[1];
        for (j = _j = _ref1 = i + 1; _ref1 <= n ? _j < n : _j > n; j = _ref1 <= n ? ++_j : --_j) {
          _ref2 = lst[j], x2 = _ref2[0], y2 = _ref2[1];
          e += 1.0 / Math.pow(Math.abs(x1 - x2) + Math.abs(y1 - y2), 2);
        }
      }
      return e;
    },
    _rotations: [[1, 0, 0, 1], [0, 1, -1, 0], [-1, 0, 0, -1], [0, -1, 1, 0]],
    _find_normalizing_rotation: function(dx, dy) {
      var dx1, dy1, t, _i, _len, _ref;
      _ref = this._rotations;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        dx1 = dx * t[0] + dy * t[1];
        dy1 = dx * t[2] + dy * t[3];
        if (dx1 > 0 && dy1 >= 0) {
          return [dx1, dy1, t];
        }
      }
      throw new Error("Impossible to rotate vector (" + dx + "," + dy + ") to the positive direction");
    },
    analyze: function(pattern, rule, max_iters, stop_on_border_hit) {
      var bestPatternSearch, cells_best, curPattern, cycle_found, iter, result, sandbox, sandbox_size, vacuum_period, x0, x1, xrange, y0, y1, yrange, _i, _ref, _ref1, _ref2;
      if (max_iters == null) {
        max_iters = 2048;
      }
      if (stop_on_border_hit == null) {
        stop_on_border_hit = true;
      }
      if (!pattern) {
        throw new Error("Pattern undefined");
      }
      if (!rule) {
        throw new Error("Rule undefined");
      }
      vacuum_period = Rules.vacuum_period(rule);
      if (vacuum_period == null) {
        throw new Error("Empty field is not periodic for this rule. Analysis impossible");
      }
      pattern = this.normalize(pattern);
      _ref = this.extent(pattern), xrange = _ref[0], yrange = _ref[1];
      sandbox_size = 64 + 2 * Math.max(xrange + yrange, pattern.length);
      sandbox = new MargolusNeighborehoodField(new Array2d(sandbox_size, sandbox_size), rule);
      sandbox.field.fill(0);
      x0 = sandbox.snap_below(div(sandbox_size - xrange, 2));
      y0 = sandbox.snap_below(div(sandbox_size - yrange, 2));
      sandbox.field.put_cells(pattern, x0, y0);
      bestPatternSearch = new Maximizer(this.energy);
      bestPatternSearch.put(pattern);
      cycle_found = false;
      for (iter = _i = 1; _i <= max_iters; iter = _i += 1) {
        sandbox.transform();
        if (iter % vacuum_period !== 0) {
          continue;
        }
        if (stop_on_border_hit) {
          if (sandbox.field.is_nonempty(0, 0, sandbox_size, 1) || sandbox.field.is_nonempty(0, 0, 1, sandbox_size)) {
            break;
          }
        }
        curPattern = sandbox.field.get_cells(0, 0, sandbox_size, sandbox_size);
        _ref1 = this.bounds(curPattern), x1 = _ref1[0], y1 = _ref1[1];
        x1 = sandbox.snap_below(x1);
        y1 = sandbox.snap_below(y1);
        this.offset(curPattern, -x1, -y1);
        if (this.areEqual(pattern, curPattern)) {
          cycle_found = true;
          break;
        }
        bestPatternSearch.put(curPattern);
      }
      result = {
        analyzed_generations: max_iters
      };
      cells_best = bestPatternSearch.getArg();
      if (cycle_found) {
        _ref2 = this.canonicalize_spaceship(cells_best, rule, x1 - x0, y1 - y0), cells_best = _ref2[0], result.dx = _ref2[1], result.dy = _ref2[2];
        result.period = iter;
      }
      result.cells = cells_best;
      return result;
    },
    canonicalize_spaceship: function(pattern, rule, dx, dy) {
      var t, _ref;
      if (dx !== 0 || dy !== 0) {
        if (Rules.is_transposable_with(rule, Bits.rotate)) {
          _ref = this._find_normalizing_rotation(dx, dy), dx = _ref[0], dy = _ref[1], t = _ref[2];
          pattern = this.transform(pattern, t);
        }
      }
      return [pattern, dx, dy];
    },
    getDualSpaceship: function(pattern, rule, dx, dy) {
      var dualPattern, dx1, dy1, name, tfm, _, _ref;
      _ref = getDualTransform(rule), name = _ref[0], tfm = _ref[1], _ = _ref[2];
      if (name === null) {
        return [null];
      }
      dualPattern = Cells.togglePhase(Cells.transform(pattern, tfm));
      dx1 = -(dx * tfm[0] + dy * tfm[1]);
      dy1 = -(dx * tfm[2] + dy * tfm[3]);
      return Cells.canonicalize_spaceship(dualPattern, rule, dx1, dy1);
    }
  };
  exports.Point = Point = {
    equal: function(_arg, _arg1) {
      var x0, x1, y0, y1;
      x0 = _arg[0], y0 = _arg[1];
      x1 = _arg1[0], y1 = _arg1[1];
      return x0 === x1 && y0 === y1;
    },
    subtract: function(_arg, _arg1) {
      var x0, x1, y0, y1;
      x0 = _arg[0], y0 = _arg[1];
      x1 = _arg1[0], y1 = _arg1[1];
      return [x0 - x1, y0 - y1];
    },
    add: function(_arg, _arg1) {
      var x0, x1, y0, y1;
      x0 = _arg[0], y0 = _arg[1];
      x1 = _arg1[0], y1 = _arg1[1];
      return [x0 + x1, y0 + y1];
    },
    isZero: function(_arg) {
      var x, y;
      x = _arg[0], y = _arg[1];
      return x === 0 && y === 0;
    },
    scale: function(_arg, k) {
      var x, y;
      x = _arg[0], y = _arg[1];
      return [x * k, y * k];
    },
    scaleRound: function(_arg, k) {
      var x, y;
      x = _arg[0], y = _arg[1];
      return [x * k | 0, y * k | 0];
    },
    corners: function(_arg, _arg1) {
      var xa, xb, ya, yb;
      xa = _arg[0], ya = _arg[1];
      xb = _arg1[0], yb = _arg1[1];
      return [[Math.min(xa, xb), Math.min(ya, yb)], [Math.max(xa, xb), Math.max(ya, yb)]];
    },
    boundBox: function(_arg, _arg1) {
      var xa, xb, ya, yb;
      xa = _arg[0], ya = _arg[1];
      xb = _arg1[0], yb = _arg1[1];
      return [Math.min(xa, xb), Math.min(ya, yb), Math.max(xa, xb) + 1, Math.max(ya, yb) + 1];
    },
    updateBoundBox: function(bbox, _arg) {
      var x, y;
      x = _arg[0], y = _arg[1];
      bbox[0] = Math.min(bbox[0], x);
      bbox[1] = Math.min(bbox[1], y);
      bbox[2] = Math.max(bbox[2], x);
      bbox[3] = Math.max(bbox[3], y);
      return bbox;
    }
  };
  /*
  # Calculates next generation of the cell list, without using field.
  # Coordinates are not limited.
  # List must contain 3-tuples: x,y,v; where v!=0
  */

  exports.evaluateLabelledCellList = evaluateLabelledCellList = function(rule, cells, phase, on_join_labels) {
    var a, b, b_x, b_y, block, block2cells, c, d, dx, dy, idx, key, merged_label, transformed, v, x, y, y_code, _i, _len, _ref, _ref1, _ref2;
    if (on_join_labels == null) {
      on_join_labels = null;
    }
    if (rule[0] !== 0) {
      throw new Error("Rule has instable vacuum and not supported.");
    }
    block2cells = {};
    for (_i = 0, _len = cells.length; _i < _len; _i++) {
      _ref = cells[_i], x = _ref[0], y = _ref[1], v = _ref[2];
      x += phase;
      y += phase;
      dx = x & 1;
      dy = y & 1;
      idx = dx + dy * 2;
      b_x = x >> 1;
      b_y = y >> 1;
      key = "" + b_x + " " + b_y;
      block = (_ref1 = block2cells[key]) != null ? _ref1 : (block2cells[key] = [0, 0, 0, 0, b_x, b_y]);
      block[idx] = v;
    }
    transformed = [];
    for (key in block2cells) {
      _ref2 = block2cells[key], a = _ref2[0], b = _ref2[1], c = _ref2[2], d = _ref2[3], b_x = _ref2[4], b_y = _ref2[5];
      b_x = (b_x << 1) - phase;
      b_y = (b_y << 1) - phase;
      y_code = rule[(a !== 0) + ((b !== 0) << 1) + ((c !== 0) << 2) + ((d !== 0) << 3)];
      merged_label = a || b || c || d;
      if (y_code & 1) {
        transformed.push([b_x, b_y, merged_label]);
      }
      if (y_code & 2) {
        transformed.push([b_x + 1, b_y, merged_label]);
      }
      if (y_code & 4) {
        transformed.push([b_x, b_y + 1, merged_label]);
      }
      if (y_code & 8) {
        transformed.push([b_x + 1, b_y + 1, merged_label]);
      }
      if (on_join_labels != null) {
        if (a && (a !== merged_label)) {
          on_join_labels(merged_label, a);
        }
        if (b && (b !== merged_label)) {
          on_join_labels(merged_label, b);
        }
        if (c && (c !== merged_label)) {
          on_join_labels(merged_label, c);
        }
        if (d && (d !== merged_label)) {
          on_join_labels(merged_label, d);
        }
      }
    }
    return transformed;
  };
  exports.getDualTransform = getDualTransform = function(rule) {
    var blockTfm, isDualBlockTfm, name, tfm, transforms, _i, _len, _ref;
    transforms = [["iden", [1, 0, 0, 1]], ["rot90", [0, 1, -1, 0]], ["rot180", [-1, 0, 0, -1]], ["rot270", [0, -1, 1, 0]], ["flipx", [-1, 0, 0, 1]], ["flipy", [1, 0, 0, -1]], ["flipxy", [0, 1, 1, 0]], ["flipixy", [0, -1, -1, 0]]];
    isDualBlockTfm = function(f, t, name) {
      var x, _i;
      for (x = _i = 0; _i <= 15; x = ++_i) {
        if (f[t[f[x]]] !== t[x]) {
          return false;
        }
      }
      return true;
    };
    for (_i = 0, _len = transforms.length; _i < _len; _i++) {
      _ref = transforms[_i], name = _ref[0], tfm = _ref[1];
      blockTfm = transformMatrix2BitBlockMap(tfm);
      if (isDualBlockTfm(rule, blockTfm, name)) {
        return [name, tfm, blockTfm];
      }
    }
    return [null];
  };
  exports.transformMatrix2BitBlockMap = transformMatrix2BitBlockMap = function(tfm) {
    var boxPoints, boxPointsT, cellsTransposition, i, tfmBitBlock, tfmCellIndex;
    boxPoints = [[-1, 0], [0, 0], [-1, -1], [0, -1]];
    boxPointsT = Cells.transform(boxPoints, tfm, false);
    tfmCellIndex = function(i) {
      return Cells.find(boxPoints, boxPointsT[i]);
    };
    cellsTransposition = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; _i <= 3; i = ++_i) {
        _results.push(tfmCellIndex(i));
      }
      return _results;
    })();
    tfmBitBlock = function(x) {
      var y, _i;
      y = 0;
      for (i = _i = 0; _i <= 3; i = ++_i) {
        if ((x >> i) & 1) {
          y = y | (1 << cellsTransposition[i]);
        }
      }
      return y;
    };
    return (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; _i <= 15; i = ++_i) {
        _results.push(tfmBitBlock(i));
      }
      return _results;
    })();
  };
  exports.evaluateCellList = evaluateCellList = function(rule, cells, phase) {
    var b_x, b_y, block, block2cells, key, transformed, x, x_code, y, y_code, _, _i, _len, _ref, _ref1, _ref2;
    if (rule[0] !== 0) {
      throw new Error("Rule has instable vacuum and not supported.");
    }
    block2cells = {};
    for (_i = 0, _len = cells.length; _i < _len; _i++) {
      _ref = cells[_i], x = _ref[0], y = _ref[1];
      x += phase;
      y += phase;
      b_x = x >> 1;
      b_y = y >> 1;
      key = "" + b_x + " " + b_y;
      block = (_ref1 = block2cells[key]) != null ? _ref1 : (block2cells[key] = [0, b_x, b_y]);
      block[0] |= 1 << ((x & 1) + (y & 1) * 2);
    }
    transformed = [];
    for (_ in block2cells) {
      _ref2 = block2cells[_], x_code = _ref2[0], b_x = _ref2[1], b_y = _ref2[2];
      b_x = (b_x << 1) - phase;
      b_y = (b_y << 1) - phase;
      y_code = rule[x_code];
      if (y_code & 1) {
        transformed.push([b_x, b_y]);
      }
      if (y_code & 2) {
        transformed.push([b_x + 1, b_y]);
      }
      if (y_code & 4) {
        transformed.push([b_x, b_y + 1]);
      }
      if (y_code & 8) {
        transformed.push([b_x + 1, b_y + 1]);
      }
    }
    return transformed;
  };
  extend_array = function(arr, arr1) {
    var x, _i, _len;
    for (_i = 0, _len = arr1.length; _i < _len; _i++) {
      x = arr1[_i];
      arr.push(x);
    }
    return arr;
  };
  return exports.splitPattern = function(rule, pattern, steps) {
    var group2labels, grp, grp_key, i, iter, label, label2group, labelled_pattern, labels, merge_labels, number_of_groups, x, y, _i, _j, _len, _ref;
    label2group = {};
    group2labels = {};
    labelled_pattern = [];
    for (i = _i = 0, _len = pattern.length; _i < _len; i = ++_i) {
      _ref = pattern[i], x = _ref[0], y = _ref[1];
      label = i + 1;
      labelled_pattern.push([x, y, label]);
      label2group[label] = label;
      group2labels[label] = [label];
    }
    number_of_groups = pattern.length;
    merge_labels = function(lab1, lab2) {
      var grp1, grp1_labels, grp2, grp2_labels, _j, _len1;
      grp1 = label2group[lab1];
      grp2 = label2group[lab2];
      if (grp1 !== grp2) {
        grp1_labels = group2labels[grp1];
        grp2_labels = group2labels[grp2];
        if ((grp1_labels == null) || (grp2_labels == null)) {
          throw new Error("assertion: group has no labels");
        }
        extend_array(grp1_labels, grp2_labels);
        delete group2labels[grp2];
        for (_j = 0, _len1 = grp2_labels.length; _j < _len1; _j++) {
          label = grp2_labels[_j];
          label2group[label] = grp1;
        }
        number_of_groups -= 1;
      }
      return null;
    };
    for (iter = _j = 0; _j <= steps; iter = _j += 1) {
      labelled_pattern = evaluateLabelledCellList(rule, labelled_pattern, iter % 2, merge_labels);
      if (number_of_groups <= 1) {
        break;
      }
    }
    return (function() {
      var _results;
      _results = [];
      for (grp_key in group2labels) {
        labels = group2labels[grp_key];
        grp = parseInt(grp_key, 10);
        _results.push((function() {
          var _k, _len1, _results1;
          _results1 = [];
          for (_k = 0, _len1 = labels.length; _k < _len1; _k++) {
            label = labels[_k];
            _results1.push(pattern[parseInt(label, 10) - 1]);
          }
          return _results1;
        })());
      }
      return _results;
    })();
  };
})(typeof exports !== "undefined" && exports !== null ? exports : this["cells"] = {});

/*
//@ sourceMappingURL=cells.map
*/
