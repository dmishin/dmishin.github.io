(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
(function() {
  var CircularInterpolatingSimulator, Simulator, Tubing, bottomRight, nGonVertices, _ref;

  _ref = require("../revca_track"), Simulator = _ref.Simulator, CircularInterpolatingSimulator = _ref.CircularInterpolatingSimulator;

  nGonVertices = function(n, r) {
    var angle, da, i, shape, _i;
    shape = [];
    da = Math.PI * 2 / n;
    for (i = _i = 0; _i < n; i = _i += 1) {
      angle = da * i;
      shape.push(r * Math.cos(angle));
      shape.push(r * Math.sin(angle));
    }
    return shape;
  };

  bottomRight = function(pattern) {
    var xy;
    return [
      Math.max.apply(Math, (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = pattern.length; _i < _len; _i++) {
          xy = pattern[_i];
          _results.push(xy[0]);
        }
        return _results;
      })()), Math.max.apply(Math, (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = pattern.length; _i < _len; _i++) {
          xy = pattern[_i];
          _results.push(xy[1]);
        }
        return _results;
      })())
    ];
  };


  /*Pure class, without THREE.js code.
   *  Creates "blueprints" of the tube geometries
   */

  exports.Tubing = Tubing = (function() {
    function Tubing(pattern, options) {
      var cx, cy, i, interpSteps, order, patH, patW, simulator, smoothing, _i, _ref1, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      this.size = (_ref1 = options.size) != null ? _ref1 : 64;
      simulator = new Simulator(this.size, this.size);
      _ref2 = bottomRight(pattern), patW = _ref2[0], patH = _ref2[1];
      cx = ((simulator.width - patW) / 2) & ~1;
      cy = ((simulator.height - patH) / 2) & ~1;
      simulator.put(pattern, cx, cy);
      order = (_ref3 = options.lanczosOrder) != null ? _ref3 : 3;
      interpSteps = (_ref4 = options.interpSteps) != null ? _ref4 : 1;
      smoothing = (_ref5 = options.smoothingPeriod) != null ? _ref5 : 4;
      this.isim = new CircularInterpolatingSimulator(simulator, order, interpSteps, smoothing);
      this.skipSteps = (_ref6 = options.skipSteps) != null ? _ref6 : 1;
      this.chunkSize = (_ref7 = options.chunkSize) != null ? _ref7 : 500;
      this.stepZ = 0.1;
      this.nCells = pattern.length;
      this.jumpTreshold = 3;
      this.prevStates = null;
      this.tubeShape = nGonVertices((_ref8 = options.tubeSides) != null ? _ref8 : 3, (_ref9 = options.tubeRadius) != null ? _ref9 : 0.1);
      this.prevNormals = new Float32Array(this.nCells * 3);
      for (i = _i = 0, _ref10 = this.nCells * 3; _i < _ref10; i = _i += 3) {
        this.prevNormals[i] = 1;
        this.prevNormals[i + 1] = 0;
        this.prevNormals[i + 2] = 0;
      }
      return;
    }

    Tubing.prototype.makeChunkBlueprint = function() {
      var i, ns, ps, states, tubes, _i, _j, _ref1;
      if (!this.prevStates) {
        this.prevStates = ps = [];
        for (i = _i = 0; _i < 3; i = ++_i) {
          ps.push(this.isim.getInterpolatedState());
          this.isim.nextTime(this.skipSteps);
        }
      }
      states = this.prevStates;
      for (i = _j = 0, _ref1 = this.chunkSize; _j < _ref1; i = _j += 1) {
        states.push(this.isim.getInterpolatedState());
        this.isim.nextTime(this.skipSteps);
      }
      tubes = (function() {
        var _k, _ref2, _results;
        _results = [];
        for (i = _k = 0, _ref2 = this.nCells; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
          _results.push(this.makeTubeBlueprint(states, i * 2));
        }
        return _results;
      }).call(this);
      ns = states.length;
      this.prevStates = [states[ns - 3], states[ns - 2], states[ns - 1]];
      return tubes;
    };

    Tubing.prototype.chunkLen = function() {
      return this.chunkSize * this.stepZ;
    };

    Tubing.prototype.makeTubeBlueprint = function(xys, tubeIndex) {
      var curIx, curV, dx, dy, dz, i, inorm1, iqxyz, ixs, iz, j, j1, jumpTreshold, nJunctions, nPipeParts, normalsIndex, pushQuad, pushXYZ, qxz, r, shape, tan, tubeEdges, vindex, vs, vx, vy, x, x_pn, xn1, xn2, xy, xyNext, xyPrev, y, y_pn, yn1, yn2, z, z_pn, zn1, zn2, _i, _j, _k, _ref1, _ref2;
      jumpTreshold = this.jumpTreshold;
      nJunctions = xys.length - 2;
      nPipeParts = xys.length - 3;
      tubeEdges = this.tubeShape.length / 2 | 0;
      vs = new Float32Array(nJunctions * tubeEdges * 3);
      ixs = new Uint16Array(nPipeParts * 2 * 3 * tubeEdges);
      curIx = 0;
      curV = 0;
      pushXYZ = function(x, y, z) {
        vs[curV] = x;
        vs[curV + 1] = y;
        vs[curV + 2] = z;
        curV += 3;
      };
      pushQuad = function(i1, i2, i3, i4) {
        ixs[curIx] = i1;
        ixs[curIx + 1] = i2;
        ixs[curIx + 2] = i3;
        ixs[curIx + 3] = i2;
        ixs[curIx + 4] = i4;
        ixs[curIx + 5] = i3;
        curIx += 6;
      };
      shape = this.tubeShape;
      r = this.tubeRadius;
      normalsIndex = (tubeIndex / 2 * 3) | 0;
      x_pn = this.prevNormals[normalsIndex];
      y_pn = this.prevNormals[normalsIndex + 1];
      z_pn = this.prevNormals[normalsIndex + 2];
      for (iz = _i = 1, _ref1 = xys.length - 1; 1 <= _ref1 ? _i < _ref1 : _i > _ref1; iz = 1 <= _ref1 ? ++_i : --_i) {
        xy = xys[iz];
        xyPrev = xys[iz - 1];
        xyNext = xys[iz + 1];
        z = (iz - 1) * this.stepZ;
        x = xy[tubeIndex];
        y = xy[tubeIndex + 1];
        dx = xyNext[tubeIndex] - xyPrev[tubeIndex];
        dy = xyNext[tubeIndex + 1] - xyPrev[tubeIndex + 1];
        dz = this.stepZ;
        iqxyz = 1.0 / Math.sqrt(dx * dx + dy * dy + dz * dz);
        dx *= iqxyz;
        dy *= iqxyz;
        dz *= iqxyz;
        tan = x_pn * dx + y_pn * dy + z_pn * dz;
        xn1 = x_pn - tan * dx;
        yn1 = y_pn - tan * dy;
        zn1 = z_pn - tan * dz;
        inorm1 = 1.0 / Math.sqrt(xn1 * xn1 + yn1 * yn1 + zn1 * zn1);
        if (isFinite(inorm1)) {
          xn1 *= inorm1;
          yn1 *= inorm1;
          zn1 *= inorm1;
        } else {
          qxz = 1.0 / Math.sqrt(dx * dx + dy * dz);
          xn1 = -dz * qxz;
          yn1 = 0.0;
          zn1 = dx * qxz;
        }
        xn2 = dy * zn1 - dz * yn1;
        yn2 = dz * xn1 - dx * zn1;
        zn2 = dx * yn1 - dy * xn1;
        vindex = curV / 3 | 0;
        for (i = _j = 0, _ref2 = shape.length; _j < _ref2; i = _j += 2) {
          vx = shape[i];
          vy = shape[i + 1];
          pushXYZ(x + xn1 * vx + xn2 * vy, y + yn1 * vx + yn2 * vy, z + zn1 * vx + zn2 * vy);
        }
        x_pn = xn1;
        y_pn = yn1;
        z_pn = zn1;
        if (iz > 1 && (Math.abs(xyPrev[tubeIndex] - x) + Math.abs(xyPrev[tubeIndex + 1] - y) < jumpTreshold)) {
          for (j = _k = 0; _k < tubeEdges; j = _k += 1) {
            j1 = (j + 1) % tubeEdges;
            pushQuad(vindex - tubeEdges + j, vindex + j, vindex - tubeEdges + j1, vindex + j1);
          }
        }
      }
      this.prevNormals[normalsIndex] = x_pn;
      this.prevNormals[normalsIndex + 1] = y_pn;
      this.prevNormals[normalsIndex + 2] = z_pn;
      if (curV !== vs.length) {
        throw new Error("Not all vertices filled");
      }
      if (curIx !== ixs.length) {
        ixs = ixs.subarray(0, curIx);
      }
      return {
        v: vs,
        idx: ixs
      };
    };

    return Tubing;

  })();

}).call(this);

},{"../revca_track":3}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
(function() {
  var Tubing, generateChunk, initialize, setOptions, tubing;

  Tubing = require("./tubing").Tubing;

  tubing = void 0;

  initialize = function(options) {
    if (options.pattern == null) {
      throw new Error("Pattern not specified!");
    }
    tubing = new Tubing(options.pattern, options);
    return self.postMessage({
      cmd: "init",
      nCells: tubing.nCells,
      fldWidth: tubing.isim.simulator.width,
      fldHeight: tubing.isim.simulator.height,
      chunkLen: tubing.chunkLen()
    });
  };

  setOptions = function(options) {
    var name, value, _i, _len, _ref;
    if (tubing == null) {
      throw new Error("Not initialized");
    }
    for (_i = 0, _len = options.length; _i < _len; _i++) {
      _ref = options[_i], name = _ref[0], value = _ref[1];
      tubing[name] = value;
    }
  };

  generateChunk = function(taskId) {
    var bp, transferables, tubeBp, _i, _len;
    bp = tubing.makeChunkBlueprint();
    transferables = [];
    for (_i = 0, _len = bp.length; _i < _len; _i++) {
      tubeBp = bp[_i];
      transferables.push(tubeBp.v.buffer);
      transferables.push(tubeBp.idx.buffer);
    }
    return self.postMessage({
      cmd: "chunk",
      taskId: taskId,
      blueprint: bp
    }, transferables);
  };

  self.addEventListener("message", function(e) {
    var cmd;
    cmd = e.data.cmd;
    if (cmd == null) {
      throw new Error("Unknown message received! " + (JSON.stringify(e.data)));
    }
    switch (cmd) {
      case "init":
        return initialize(e.data);
      case "chunk":
        return generateChunk(e.data.taskId);
      case "set":
        return setOptions(e.data.options);
      default:
        throw new Error("Unknown command received by worker: " + cmd);
    }
  });

}).call(this);

},{"./tubing":1}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
(function() {
  var CircularInterpolatingSimulator, Rules, Simulator, Transforms, addScaled, fillZeros, lanczosInterpolator, lanczosKernel, makeRule, mod, mod2, newFloatArray, newInt8Array, sinc, snap,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  mod2 = function(x) {
    return x & 1;
  };

  mod = function(x, y) {
    var m;
    m = x % y;
    if (m < 0) {
      return m + y;
    } else {
      return m;
    }
  };

  snap = function(x, t) {
    return x - mod2(x + t);
  };

  exports.makeRule = makeRule = function(ruleString) {
    var code, codes, codes2tfm, iCode, part, rule, tfm, tfmName, _i, _j, _len, _len1, _ref, _ref1;
    rule = {};
    _ref = ruleString.split(";");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      part = _ref[_i];
      codes2tfm = part.split(":");
      if (codes2tfm.length !== 2) {
        throw new Error("Parse error: " + part + " must have form n1,n2,...:tfm");
      }
      codes = codes2tfm[0], tfmName = codes2tfm[1];
      tfm = Transforms[tfmName.trim()];
      if (tfm == null) {
        throw new Error("Parse error: unknown transform " + tfmName);
      }
      _ref1 = codes.split(",");
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        code = _ref1[_j];
        iCode = parseInt(code.trim(), 10);
        if (__indexOf.call([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], iCode) < 0) {
          throw new Error("Error: code must be in range 0..15");
        }
        if (rule[iCode] != null) {
          throw new Error("Error: code " + iCode + " (");
        }
        rule[iCode] = tfm;
      }
    }
    return rule;
  };

  Transforms = {
    rot90: function(dx, dy) {
      return [-dy, dx];
    },
    rot180: function(dx, dy) {
      return [-dx, -dy];
    },
    rot270: function(dx, dy) {
      return [dy, -dx];
    },
    flipX: function(dx, dy) {
      return [-dx, dy];
    },
    flipY: function(dx, dy) {
      return [dx, -dy];
    },
    flipDiag: function(dx, dy) {
      return [dy, dx];
    },
    flipADiag: function(dx, dy) {
      return [-dy, -dx];
    }
  };

  fillZeros = function(arr) {
    var i, _i, _ref;
    for (i = _i = 0, _ref = arr.length; _i < _ref; i = _i += 1) {
      arr[i] = 0;
    }
    return arr;
  };

  newInt8Array = typeof Int8Array !== "undefined" && Int8Array !== null ? function(sz) {
    return new Int8Array(sz);
  } : function(sz) {
    return fillZeros(new Array(sz));
  };

  newFloatArray = typeof Float32Array !== "undefined" && Float32Array !== null ? function(sz) {
    return new Float32Array(sz);
  } : function(sz) {
    return fillZeros(new Array(sz));
  };

  exports.Rules = Rules = {
    singleRotation: {
      1: Transforms.rot90,
      2: Transforms.rot90,
      4: Transforms.rot90,
      8: Transforms.rot90
    }
  };

  exports.Simulator = Simulator = (function() {
    function Simulator(width, height, rule) {
      this.width = width;
      this.height = height;
      this.rule = rule != null ? rule : Rules.singleRotation;
      this.cells = [];
      this.field = newInt8Array(this.width * this.height);
      this.field1 = newInt8Array(this.width * this.height);
      this.phase = 0;
    }

    Simulator.prototype.cellCount = function() {
      return (this.cells.length / 2) | 0;
    };

    Simulator.prototype.index = function(x, y) {
      return x + y * this.width;
    };

    Simulator.prototype.indexw = function(x, y) {
      return this.index(mod(x, this.width), mod(y, this.height));
    };

    Simulator.prototype.putCell = function(x, y) {
      var c, idx;
      idx = this.index(x, y);
      if (this.field[idx] === 0) {
        c = this.cells;
        c.push(x);
        c.push(y);
        this.field[idx] = 1;
        return c.length - 1;
      } else {
        return null;
      }
    };

    Simulator.prototype.put = function(pattern, x0, y0) {
      var x, y, _i, _len, _ref;
      if (x0 == null) {
        x0 = 0;
      }
      if (y0 == null) {
        y0 = 0;
      }
      for (_i = 0, _len = pattern.length; _i < _len; _i++) {
        _ref = pattern[_i], x = _ref[0], y = _ref[1];
        this.putCell(x + x0, y + y0);
      }
    };

    Simulator.prototype.getCells = function() {
      var cc, i, _i, _ref, _results;
      cc = this.cells;
      _results = [];
      for (i = _i = 0, _ref = cc.length; _i < _ref; i = _i += 2) {
        _results.push([cc[i], cc[i + 1]]);
      }
      return _results;
    };

    Simulator.prototype.clear = function() {
      this.cells = [];
      this.phase = 0;
      this.field = newInt8Array(this.width * this.height);
    };

    Simulator.prototype.blockCode = function(x, y) {
      var f;
      f = this.field;
      return f[this.indexw(x, y)] * 1 + f[this.indexw(x + 1, y)] * 2 + f[this.indexw(x, y + 1)] * 4 + f[this.indexw(x + 1, y + 1)] * 8;
    };

    Simulator.prototype.step = function() {
      var dx, dy, field1, i, nextCells, oldCells, phase, tfm, x, x0, x1, y, y0, y1, _i, _j, _ref, _ref1, _ref2, _ref3;
      phase = this.phase;
      nextCells = [];
      field1 = this.field1;
      for (i = _i = 0, _ref = this.field1.length; _i < _ref; i = _i += 1) {
        field1[i] = 0;
      }
      for (i = _j = 0, _ref1 = this.cells.length; _j < _ref1; i = _j += 2) {
        x = this.cells[i];
        y = this.cells[i + 1];
        x0 = snap(x, phase);
        y0 = snap(y, phase);
        tfm = this.rule[this.blockCode(x0, y0)];
        if (tfm != null) {
          _ref2 = tfm(x - x0 - 0.5, y - y0 - 0.5), dx = _ref2[0], dy = _ref2[1];
          x1 = mod((x0 + 0.5 + dx) | 0, this.width);
          y1 = mod((y0 + 0.5 + dy) | 0, this.height);
        } else {
          x1 = x;
          y1 = y;
        }
        this.field1[this.index(x1, y1)] = 1;
        nextCells.push(x1);
        nextCells.push(y1);
      }
      _ref3 = [this.field, this.field1], this.field1 = _ref3[0], this.field = _ref3[1];
      this.phase = this.phase ^ 1;
      oldCells = this.cells;
      this.cells = nextCells;
      return oldCells;
    };

    return Simulator;

  })();

  sinc = function(x) {
    if (Math.abs(x) > 1e-8) {
      return Math.sin(x) / x;
    } else {
      return 1 - x * x / 6;
    }
  };

  lanczosKernel = function(a, n) {
    var ix, x, _i, _ref, _ref1, _results;
    if (a !== a | 0) {
      throw new Error("A must be integer");
    }
    _results = [];
    for (ix = _i = _ref = -a * n, _ref1 = a * n; _i <= _ref1; ix = _i += 1) {
      x = ix / n * Math.PI;
      _results.push(sinc(x) * sinc(x / a));
    }
    return _results;
  };

  lanczosInterpolator = function(a, n, downscale) {
    var interpolate, kernel, maxNumStates;
    if (downscale == null) {
      downscale = 1;
    }
    kernel = lanczosKernel(a, n * downscale);
    interpolate = function(states, offset) {
      var i, idx, state, sum, _i, _len;
      if (offset >= n || offset < 0) {
        throw new Error("Incorrect offset, must be in [0; " + n + ") ");
      }
      sum = newFloatArray(states[0].length);
      for (i = _i = 0, _len = states.length; _i < _len; i = ++_i) {
        state = states[i];
        idx = i * n + offset;
        if (idx >= kernel.length) {
          break;
        }
        addScaled(sum, state, kernel[idx]);
      }
      return sum;
    };
    maxNumStates = 2 * a * downscale;
    return [interpolate, maxNumStates];
  };

  addScaled = function(a, b, k) {
    var bi, i, _i, _len;
    for (i = _i = 0, _len = b.length; _i < _len; i = ++_i) {
      bi = b[i];
      a[i] += bi * k;
    }
    return a;
  };

  exports.CircularInterpolatingSimulator = CircularInterpolatingSimulator = (function() {
    function CircularInterpolatingSimulator(simulator, order, timeSteps, smoothing) {
      var _ref;
      this.simulator = simulator;
      this.timeSteps = timeSteps;
      this.smoothing = smoothing != null ? smoothing : 1;
      this.order = order * smoothing;
      _ref = lanczosInterpolator(this.order, this.timeSteps, this.smoothing), this.interpolator = _ref[0], this.neededStates = _ref[1];
      this.states = [];
      this._fillBuffer();
      this.time = 0;
    }

    CircularInterpolatingSimulator.prototype.setSmoothing = function(newSmoothing) {
      var _ref;
      if (newSmoothing === this.smoothing) {
        return;
      }
      this.smoothing = newSmoothing;
      _ref = lanczosInterpolator(this.order, this.timeSteps, newSmoothing), this.interpolator = _ref[0], this.neededStates = _ref[1];
      return this._fillBuffer();
    };

    CircularInterpolatingSimulator.prototype.put = function(pattern, x0, y0) {
      var h, newStates, w, x, y, _i, _len, _ref;
      if (x0 == null) {
        x0 = 0;
      }
      if (y0 == null) {
        y0 = 0;
      }
      newStates = [];
      w = this.simulator.width;
      h = this.simulator.height;
      for (_i = 0, _len = pattern.length; _i < _len; _i++) {
        _ref = pattern[_i], x = _ref[0], y = _ref[1];
        x = mod(x + x0, w);
        y = mod(y + y0, h);
        if (this.simulator.putCell(x, y) != null) {
          newStates.push(x);
          newStates.push(y);
        }
      }
      this._appendStateToBuffer(this._mapState(newStates));
      return newStates.length;
    };

    CircularInterpolatingSimulator.prototype.putCell = function() {
      var xy;
      xy = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.put([xy]);
    };

    CircularInterpolatingSimulator.prototype.clear = function() {
      var i;
      this.simulator.clear();
      this.states = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.neededStates; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push([]);
        }
        return _results;
      }).call(this);
    };

    CircularInterpolatingSimulator.prototype._appendStateToBuffer = typeof Float32Array !== "undefined" && Float32Array !== null ? function(tail) {
      var newState, state;
      this.states = (function() {
        var _i, _len, _ref, _results;
        _ref = this.states;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          state = _ref[_i];
          newState = newFloatArray(state.length + tail.length);
          newState.set(state);
          newState.set(tail, state.length);
          _results.push(newState);
        }
        return _results;
      }).call(this);
    } : function(tail) {
      var state;
      this.states = (function() {
        var _i, _len, _ref, _results;
        _ref = this.states;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          state = _ref[_i];
          _results.push(state.concat(tail));
        }
        return _results;
      }).call(this);
    };

    CircularInterpolatingSimulator.prototype._getState = function() {
      return this._mapState(this.simulator.step());
    };

    CircularInterpolatingSimulator.prototype._mapState = function(s) {
      var i, ih, iw, j, nx, ny, s1, _i, _ref;
      s1 = newFloatArray(s.length * 2);
      iw = 2 * Math.PI / this.simulator.width;
      ih = 2 * Math.PI / this.simulator.height;
      for (i = _i = 0, _ref = s.length; _i < _ref; i = _i += 2) {
        j = i * 2;
        nx = s[i] * iw;
        s1[j] = Math.cos(nx);
        s1[j + 1] = Math.sin(nx);
        ny = s[i + 1] * ih;
        s1[j + 2] = Math.cos(ny);
        s1[j + 3] = Math.sin(ny);
      }
      return s1;
    };

    CircularInterpolatingSimulator.prototype._unMapState = function(s) {
      var PI2, cx, cy, i, j, kx, ky, s1, sx, sy, wrapPi, _i, _ref;
      kx = this.simulator.width / (2 * Math.PI);
      ky = this.simulator.height / (2 * Math.PI);
      PI2 = Math.PI * 2;
      wrapPi = function(x) {
        if (x > 0) {
          return x;
        } else {
          return x + PI2;
        }
      };
      s1 = newFloatArray(s.length / 2);
      for (i = _i = 0, _ref = s.length; _i <= _ref; i = _i += 4) {
        j = (i / 2) | 0;
        cx = s[i];
        sx = s[i + 1];
        cy = s[i + 2];
        sy = s[i + 3];
        s1[j] = wrapPi(Math.atan2(sx, cx)) * kx;
        s1[j + 1] = wrapPi(Math.atan2(sy, cy)) * ky;
      }
      return s1;
    };

    CircularInterpolatingSimulator.prototype._fillBuffer = function() {
      if (this.states.length > this.neededStates) {
        this.states = this.states.slice(this.states.length - this.neededStates, this.states.length);
      } else {
        while (this.states.length < this.neededStates) {
          this.states.push(this._getState());
        }
      }
    };

    CircularInterpolatingSimulator.prototype.getInterpolatedState = function() {
      return this._unMapState(this.interpolator(this.states, this.timeSteps - this.time - 1));
    };

    CircularInterpolatingSimulator.prototype.nextTime = function(dt) {
      this.time += dt;
      while (this.time >= this.timeSteps) {
        this.time -= this.timeSteps;
        this.states = this.states.slice(1);
        this.states.push(this._getState());
      }
      return this.time;
    };

    return CircularInterpolatingSimulator;

  })();

}).call(this);

},{}]},{},[2]);
