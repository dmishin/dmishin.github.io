// Generated by CoffeeScript 1.6.3
var WritableByteStream;

WritableByteStream = (function() {
  function WritableByteStream(chunkSize) {
    if (chunkSize == null) {
      chunkSize = 1024;
    }
    this.chunkSize = chunkSize;
    this.curChunkPos = 0;
    this.curChunk = this.newChunk();
    this.chunks = [this.curChunk];
  }

  /*
  How many bytes currently contained in the stream
  */


  WritableByteStream.prototype.getSize = function() {
    return (this.chunks.length - 1) * this.chunkSize + this.curChunkPos;
  };

  /*
  Create new chunk
  */


  WritableByteStream.prototype.newChunk = function() {
    var e;
    try {
      return new Uint8Array(this.chunkSize);
    } catch (_error) {
      e = _error;
      return [];
    }
  };

  /*
  Get data as base-64 string
  */


  WritableByteStream.prototype.getB64Data = function() {
    var addChr, chr, chunk, chunkLen, encodeBlock, hasChrs, iChunk, j, key, lastChunkIdx, output, _i, _j, _len, _ref;
    output = "";
    key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    chr = [];
    hasChrs = 0;
    addChr = function(c) {
      if (hasChrs >= 3) {
        encodeBlock();
        hasChrs = 0;
      }
      return chr[hasChrs++] = c;
    };
    encodeBlock = function() {
      var enc1, enc2, enc3, enc4;
      enc1 = chr[0] >> 2;
      enc2 = ((chr[0] & 3) << 4) | (chr[1] >> 4);
      enc3 = hasChrs < 2 ? 64 : ((chr[1] & 15) << 2) | (chr[2] >> 6);
      enc4 = hasChrs < 3 ? 64 : chr[2] & 63;
      return output += key.charAt(enc1) + key.charAt(enc2) + key.charAt(enc3) + key.charAt(enc4);
    };
    lastChunkIdx = this.chunks.length - 1;
    _ref = this.chunks;
    for (iChunk = _i = 0, _len = _ref.length; _i < _len; iChunk = ++_i) {
      chunk = _ref[iChunk];
      chunkLen = iChunk === lastChunkIdx ? this.curChunkPos : this.chunkSize;
      for (j = _j = 0; _j < chunkLen; j = _j += 1) {
        addChr(chunk[j]);
      }
    }
    if (hasChrs > 0) {
      encodeBlock();
    }
    return output;
  };

  WritableByteStream.prototype.writeByte = function(val) {
    var p;
    p = this.curChunkPos;
    this.curChunk[p++] = val;
    if (p < this.chunkSize) {
      return this.curChunkPos = p;
    } else {
      this.curChunkPos = 0;
      return this.chunks.push((this.curChunk = this.newChunk()));
    }
  };

  WritableByteStream.prototype.writeUTFBytes = function(string) {
    var i, _i, _ref;
    for (i = _i = 0, _ref = string.length; _i < _ref; i = _i += 1) {
      this.writeByte(string.charCodeAt(i));
    }
    return null;
  };

  WritableByteStream.prototype.writeBytes = function(array, offset, length) {
    var i, _i;
    if (offset == null) {
      offset = 0;
    }
    if (length == null) {
      length = array.length;
    }
    for (i = _i = offset; _i < length; i = _i += 1) {
      this.writeByte(array[i]);
    }
    return null;
  };

  return WritableByteStream;

})();

/*
//@ sourceMappingURL=WritableStream.map
*/
